%!TEX root = ./main.tex
\chapter{Marco teorico}
\label{ch:marco_teorico}
\graphicspath{{figs/}}



% -------------------------------------------------------------
% SECCIÓN 1: Fundamentos del Problema
% -------------------------------------------------------------
\section{Sistemas de Tiempo Real y Trazabilidad}
\label{sec:sistemas_tiempo_real}

Este apartado establece el contexto y la necesidad de la investigación, justificando por qué la medición temporal es crítica en el campo de aplicación.
\subsection{Definición de Sistemas de Tiempo Real (STR)}
\label{ssec:definicion_str}

Un \textbf{Sistema de Tiempo Real (STR)} es aquel cuya corrección no depende únicamente de la precisión lógica del resultado de un cómputo, sino también del \textbf{momento exacto en que dicho resultado se produce}. En estos sistemas, el cumplimiento de las restricciones temporales (\textit{deadlines}) es un factor crucial. La gravedad del fallo al no cumplir con estas restricciones da lugar a dos clasificaciones principales (ver~\cite{liu2006real}):
\begin{itemize}
\item \textbf{Sistema de Tiempo Real Estricto (\textit{Hard Real-Time}):} En estos sistemas, las restricciones temporales son de máxima prioridad. El \textbf{incumplimiento de una fecha límite se considera un fallo} del sistema. Un retraso, por mínimo que sea, puede tener consecuencias de fiabilidad.    
 \item \textbf{Sistema de Tiempo Real Flexible (\textit{Soft Real-Time}):} El incumplimiento ocasional de una fecha límite es indeseable y degrada el rendimiento o la calidad del servicio, pero \textbf{no conduce a un fallo total} del sistema. En este caso, el valor del resultado disminuye después de su \textit{deadline}, pero el sistema puede tolerar las violaciones ocasionales.
\end{itemize}



Dado que el objetivo del presente proyecto es evaluar el desempeño de un programa con la máxima precisión posible, el mecanismo de trazabilidad desarrollado debe aspirar a la fiabilidad de un entorno \textit{Hard Real-Time}. Esto requiere garantizar la \textbf{predictibilidad} y la \textbf{mínima intrusión} de la herramienta de medición.


\subsection{Necesidad de la Trazabilidad Temporal (\textit{Tracing}) y el Problema de la Intrusión}
\label{ssec:problema_latencia}

La evaluación del desempeño de cualquier STR requiere medir con precisión los \textbf{tiempos de respuesta} y los \textbf{intervalos de tiempo} entre eventos de interés del sistema. Este proceso de medición se conoce como \textbf{trazabilidad} o \textit{tracing}, y consiste en registrar la secuencia de eventos del programa junto con una marca temporal (\textit{timestamp}) asociada a cada uno.

El principal desafío metodológico en la trazabilidad de STR es el \textbf{Efecto Sonda} o \textbf{Intrusión de la Medición} (\textit{probe effect}). Este fenómeno ocurre cuando la herramienta utilizada para la medición afecta el comportamiento temporal del sistema que se está observando.

Un ejemplo de esta limitación se evidenció en proyectos antecesor que empleaban técnicas de \textit{debugging} para la trazabilidad. Estos enfoques se basaban en la interrupción del tiempo de ejecución del procesador para generar las marcas temporales, resultando en un método altamente intrusivo y, por ende, \textbf{no fiable} para la medición de sistemas deterministas.

Las técnicas de trazabilidad basadas en \textbf{software} (como la inserción de llamadas a funciones de registro o contadores en el código del programa) son inherentemente intrusivas debido a dos razones principales:
\begin{enumerate}
    \item \textbf{Alteración de la Temporización:} La ejecución del código de registro consume tiempo de CPU y recursos de memoria, añadiendo una latencia variable que altera la secuencia temporal original del programa.
    \item \textbf{Distorsión del Contexto:} El código de instrumentación puede modificar el uso de la caché o la jerarquía de memoria, lo que cambia las condiciones bajo las cuales el programa se ejecutaría normalmente.
\end{enumerate}

Para sistemas que aspiran a la predictibilidad de un entorno \textit{Hard Real-Time}, esta alteración es inaceptable, ya que invalida los resultados de la medición.

Por lo tanto, la solución propuesta en este proyecto es el desarrollo del \textbf{Módulo Reporter}, una herramienta de \textbf{trazabilidad basada en hardware} implementada en la Lógica Programable (PL) de la FPGA. Al operar de manera paralela y asíncrona al procesador bajo prueba (\textit{soft-core}), el Módulo Reporter minimiza la intrusión y se espera obtener \textit{timestamps} de alta fidelidad, superando las limitaciones impuestas por las técnicas de instrumentación basadas en software.

% -------------------------------------------------------------
% SECCIÓN 2: Plataforma de Hardware: FPGA y Arquitectura Zynq
% -------------------------------------------------------------
\section{Arquitectura Heterogénea en Sistemas de Lógica Programable}
\label{sec:arquitectura_fpga}

Se describe la plataforma física sobre la que se implementará la solución, detallando la interconexión PS-PL.

\subsection{Fundamentos de Field-Programmable Gate Arrays (FPGA)}
\label{ssec:fundamentos_fpga}
% Brevemente la tecnología: Lógica Programable (PL) vs. Processing System (PS).

\subsection{Arquitectura System-on-Chip (SoC) Zynq}
\label{ssec:arquitectura_zynq}

Para el desarrollo de sistemas embebidos complejos, la tendencia tecnológica se centra en las arquitecturas heterogéneas conocidas como \textbf{System-on-Chip (SoC)}. La arquitectura \textbf{Zynq} (de Xilinx, ahora AMD) esta tecnología, que integra un sistema de procesamiento de propósito general junto con la lógica programable en un único circuito integrado  . Este enfoque es importante para el presente proyecto, ya que proporciona una plataforma unificada para la \textit{trazabilidad} y el \textit{análisis} de datos.

La arquitectura Zynq se divide en dos secciones principales, como se ilustra en la \cref{fig:zynq_model}. Estas secciones son:

\begin{itemize}
    \item \textbf{Processing System (PS):} Corresponde al núcleo de procesamiento, que incluye procesadores \textbf{ARM Cortex-A9} (en la serie Zynq-7000), controladores de memoria caché, controladores de memoria DDR y periféricos. El PS está diseñado para ejecutar un sistema operativo complejo como \textbf{Linux} y actúa como la plataforma anfitriona para la recepción, el almacenamiento y el procesamiento de los datos de eventos generados por la lógica de \textit{hardware}.
    
    \item \textbf{Programmable Logic (PL):} Es la sección de FPGA, que contiene bloques lógicos reconfigurables (CLBs), memoria BRAM y recursos DSP. La PL es el dominio del \textbf{hardware personalizado} donde se sintetizarán el procesador \textit{soft-core} RISC-V y el \textbf{Módulo Reporter}. Esta sección es esencial para implementar el mecanismo de \textit{tracing} con mínima intrusión.
\end{itemize}

La interconexión de estos dos dominios está a cargo de la \textbf{interfaz AXI} (\textit{Advanced eXtensible Interface}), un bus de comunicación de alto rendimiento que permite el intercambio eficiente y sincronizado de datos entre el PS y la PL. El Módulo Reporter utilizará esta interfaz para transmitir los \textit{timestamps} y los datos de eventos generados en el \textit{soft-core} directamente a la memoria del PS para su posterior análisis en el entorno Linux. (ver \cite{crockett2014zynq})

\begin{figure}[h!] % [h!] es un modificador de posición
    \centering
    \includegraphics[width=0.8\textwidth]{figs/Architecture_simple.png}
    \caption{Modelo simplificado de la arquitectura Zynq.}
    \label{fig:zynq_model}
\end{figure}
Para profundizar en el contexto de implementación, este subapartado describe con mayor detalle la arquitectura del System-on-Chip (SoC) Zynq. Se establece la configuración y disposición de sus componentes clave, fundamentales para sustentar la hipótesis del trabajo.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{figs/Architecture_simple_distribucion.png} 
    \caption{Relación entre el sistema de software, el sistema de hardware y la arquitectura Zynq}
    \label{fig:zynq_Relationship}
\end{figure}

\subsection{Uso de Linux en el Processing System (PS)}
\label{ssec:linux_ps}
% Justificación del uso de Linux para recepción, procesamiento y almacenamiento de datos.

% -------------------------------------------------------------
% SECCIÓN 3: La Unidad Bajo Prueba y la Interconexión
% -------------------------------------------------------------
\section{Procesadores Soft-Core y Protocolo de Comunicación}
\label{sec:softcore_comunicacion}

Se centra en la unidad que genera los eventos y el medio por el cual se transfieren.

\subsection{Procesador Soft-Core RISC-V}
\label{ssec:riscv}
% Introducción al ISA RISC-V.
% Requisitos para la síntesis en PL: acceso a registros (PC) y generación de señales de evento.
% ----------------------------------------------------------------------------------------
\subsection{Procesador Soft-Core RISC-V: Análisis y Selección}
\label{ssec:seleccion_softcore}

% --- 1. Introducción y Objetivo ---
La elección del núcleo de procesamiento que operará como \textit{soft-core} en la Lógica Programable (PL) es una decisión crítica para la metodología de trazabilidad del proyecto. Este núcleo constituye el \textbf{Sistema Bajo Prueba (SUT)} y su arquitectura impacta directamente tanto la capacidad de acceder a registros internos como la minimización de la intrusión. Por lo tanto, el objetivo es realizar una evaluación comparativa para seleccionar el núcleo que ofrezca el mejor equilibrio entre rendimiento, consumo de recursos y flexibilidad para la instrumentación.

Los candidatos evaluados para esta implementación son:
\begin{itemize}
    \item VexRiscv
    \item Ibex
    \item PicoRV32
\end{itemize}

% --- 2. Criterios de Selección ---
\subsubsection{Criterios de Selección Técnica}

La evaluación de los candidatos se basará en criterios técnicos específicos, diseñados para garantizar la viabilidad y precisión del Módulo Reporter, así como la robustez del producto final:

\begin{enumerate}
% Uso de Recursos
    \item \textbf{Tamaño y Consumo de Recursos:} Requisitos de Lógica Programable (LUTs, FFs, BRAMs) en la FPGA. Un menor consumo es preferible para asegurar espacio para el Módulo Reporter y reducir la complejidad del enrutamiento.
% Arq. Pipeline   
    \item \textbf{Flexibilidad y Customización:} Capacidad de modificar la arquitectura interna y el \textbf{pipeline} del núcleo para exponer registros clave del CPU (ej., el \textit{Program Counter}, PC).
% Historial   
    \item \textbf{Predictibilidad:} Arquitectura que favorezca un comportamiento determinista, minimizando la latencia y el \textbf{jitter} temporal, factores vitales en sistemas de tiempo real.
% Flexibilidad
    \item \textbf{Capacidad de \textit{Tracing}:} Evaluación de los puertos de \textit{debug} o señales internas accesibles, esenciales para la captura de eventos en la PL.
% Timestaping No Intrusivo
% Comunidad    
    \item \textbf{Comunidad y Documentación:} Este factor es fundamental para garantizar la robustez, el mantenimiento a largo plazo y la disponibilidad de soporte técnico para el proyecto.
% Frecuencia Zybo
% Heritage Aeroespacial
     \item \textbf{Antecedentes Industriales:} Historial de uso o certificación del núcleo en la industria aeroespacial o en entornos de seguridad crítica, lo cual es relevante para el objetivo de replicabilidad y aplicación en dicho campo. \textbf{Antecedentes Industriales:} Historial de uso o certificación del núcleo en la industria aeroespacial o en entornos de seguridad crítica, lo cual es relevante para el objetivo de replicabilidad y aplicación en dicho campo.
% Bus Sniffing
    \item \textbf{Bus Sniffing:} Capacidad de monitorear transacciones del bus  sin intervenir, lo cual es importante para \textit{debugging} de interacciones de memoria/perfiféricos.
% Overhead Trazabilidad
    \item \textbf{Overhead de Trazabilidad:} Es el impacto en performance cuando el tracing está activo. 


\end{enumerate}

% --- 3. Análisis Comparativo (Tabla Formal) ---
\subsubsection{Análisis Comparativo de VexRiscv e Ibex}
Se descartó el \textit{soft-core PicoRV32} porque sus métricas, previamente evaluadas, no se adaptaban a los estándares del proyecto. A continuación, se presenta una comparación formal de las métricas clave de ambos núcleos \textit{soft-core}, obtenidas de su documentación oficial y validaciones en la literatura:

\begin{table}[h!]
    \centering
    \caption{Comparación de Soft-Cores RISC-V: Análisis de Trazabilidad}
    \label{tab:comparacion_softcores}
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Criterio de Evaluación} & \textbf{VexRiscv} & \textbf{Ibex} \\
        \hline
        \hline
        \textbf{1. Uso de Recursos (LUTs)} & 1,800-3,500 & 2,000-4,000 \\
        \hline
        \textbf{2. Arquitectura de Pipeline} & 5 etapas (configurable) & 2 etapas (principal) \\
        \hline
        \textbf{3. Predictibilidad y Determinismo} & Alta (configurable) & Muy Alta (2-etapas simple) \\
        \hline
        \textbf{4. Historial de Seguridad} & OpenTitan (derivados) & OpenTitan (core principal) \\
        \hline
        \textbf{5. Flexibilidad para Tracing} & Muy Alta (sistema plugins) & Alta (Debug Spec 0.13) \\
        \hline
        \textbf{6. Timestamping No Intrusivo} & Excelente (observadores HW) & Bueno (performance counters) \\
        \hline
        \textbf{7. Comunidad y Soporte} & Muy Activa (SpinalHDL) & Activa (lowRISC/Google) \\
        \hline
        \textbf{8. Frecuencia Máxima (Zybo)} & 150-200 MHz & 100-150 MHz \\
        \hline
        \textbf{9. Heritage Aeroespacial} & Prototipos (académico) & OpenTitan (seguridad) \\
        \hline
        \textbf{10. Bus Sniffing} & Nativo (plugins) & Posible (extensiones) \\
        \hline
        \textbf{11. Overhead de Trazabilidad} & 0-2\% (hardware) & 1-3\% (debug module) \\
        \hline
    \end{tabular}
\end{table}


% --- 4. Decisión y Justificación ---
\subsubsection{Decisión y Justificación del Núcleo Seleccionado}

\textbf{Decisión:} Se opta por la implementación del núcleo \textbf{IBEX} como Sistema Bajo Prueba (SUT).

\textbf{Justificación:} Esta selección se basa en la priorización del criterio de \textbf{minimización de recursos} y \textbf{predictibilidad}. Ibex requiere un menor \textit{footprint} de Lógica Programable, lo cual:

\begin{enumerate}
    \item Garantiza que la PL tenga la capacidad suficiente para la implementación del \textbf{Módulo Reporter} y sus subsistemas de \textit{timestamping}.
    \item \textbf{Minimiza el riesgo de \textbf{timing closure} y facilita la replicabilidad} del \textit{setup} experimental.
    \item Ofrece una arquitectura más simple que, aunque pueda tener una \textit{Fmax} menor que el ARM del PS, presenta una \textbf{mejor predictibilidad temporal}, factor esencial para la validez de los \textit{timestamps} recolectados.
\end{enumerate}


%-----------------------------------------------------------------------------------------
\subsection{Protocolo Advanced eXtensible Interface (AXI)}
\label{ssec:protocolo_axi}
% Explicar AXI como estándar de comunicación eficiente (Master/Slave) entre los bloques de hardware.
Los buses \textit{AXI} se pueden usar de forma flexible y, en general, se utilizan para conectar el/los procesador/es y otros bloques IP en un sistema embebido. De hecho, existen tres variantes de \textit{AXI4}(\textit{AXI4} es la versión en la que contribuyó \textit{Xilinx} para su definición), cada una de las cuales representa un protocolo de bus diferente, como se resume a continuación. La elección del protocolo de bus \textit{AXI} para una conexión específica depende de las propiedades deseadas de dicha conexión.

\begin{itemize}
    \item \textit{AXI4}: Para enlaces asignados a memoria, y para proporcionar el mayor rendimiento: se proporciona una dirección seguida de una transferencia de ráfaga de datos de hasta 256 palabras de datos (o \textit{data beats}).

    \item \textit{AXI4-Lite}: Un enlace simplificado que admite una sola transferencia de datos por conexión (sin ráfagas). \textit{AXI4-Lite} también utiliza mapeo de memoria: en este caso, se transfieren una dirección y una única palabra de datos.
    
    \item \textit{AXI4-Stream}: Para transmisión de datos a alta velocidad, admite transferencias en ráfaga de tamaño ilimitado. No dispone de mecanismo de direccionamiento; este tipo de bus es ideal para el flujo directo de datos entre origen y destino (sin mapeo de memoria).
\end{itemize}

\textbf{Interfaz AXI e Interconexiones}
La interfaz principal entre la PS y la PL se realiza mediante un conjunto de nueve interfaces AXI, cada una compuesta por múltiples canales. Estas establecen conexiones dedicadas entre la PL y las interconexiones dentro de la PS, como se indica en la \cref{fig:AXI_II}. Es útil definir brevemente estos dos términos importantes:

\begin{itemize}
    \item Interfaz: Una conexión punto a punto para el intercambio de datos, direcciones y señales de negociación entre clientes maestros y esclavos dentro del sistema.

    \item Interconexión: Una interconexión es, en esencia, un conmutador que gestiona y dirige el tráfico entre las interfaces \textit{AXI} conectadas. Existen varias interconexiones dentro del PS; algunas se conectan directamente al PL (como se muestra en la \cref{fig:AXI_II}) y otras son de uso interno únicamente. Las conexiones entre estas interconexiones también se establecen mediante interfaces \textit{AXI}.
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{figs/Interface_Interconection_AXI.png} 
    \caption{La estructura de las interconexiones e interfaces AXI que conectan la fuente de alimentación (PS) y la línea de procesamiento (PL).}
    \label{fig:AXI_II}
\end{figure}

%\textbf{OPCIONAL - NO SE SI ES NECESARIO ENTRAR TANTO EN EL TEMA DE LAS INTERFACES E INTERCONEXIONES}

%\begin{table}[!ht]
%    \centering
 %   \caption{Interfaces entre PS y PL}
%    \begin{tabular}{|l|l|l|l|}
%    \hline
%        \textbf{Nombre Interfaz} & \textbf{Descripción interfax} & \textbf{Maestro} & \textbf{Esclavo} \\ \hline
%        \textbf{M\_AXI\_GP0} & Proposito General (AXI\_GP) & PS & PL \\ \hline
%        \textbf{M\_AXI\_GP1} & Proposito General (AXI\_GP) & PS & PL \\ \hline
%        \textbf{S\_AXI\_GP0} & Proposito General (AXI\_GP) & PL & PS \\ \hline
%        \textbf{S\_AXI\_GP1} & Proposito General (AXI\_GP) & PL & PS \\ \hline
%        \textbf{S\_AXI\_ACP } & Puerto de coherencia del acelerador (ACP), transacción coherente de caché & PL & PS \\ \hline
%        \textbf{S\_AXI\_HP0} & Puertos de alto rendimiento (AXI\_HP) con FIFO de lectura/escritura. & PL & PS \\ \hline
%        \textbf{S\_AXI\_HP1} & Puertos de alto rendimiento (AXI\_HP) con FIFO de lectura/escritura. & PL & PS \\ \hline
%        \textbf{S\_AXI\_HP2} & Puertos de alto rendimiento (AXI\_HP) con FIFO de lectura/escritura. & PL & PS \\ \hline
%        \textbf{S\_AXI\_HP3} & Puertos de alto rendimiento (AXI\_HP) con FIFO de lectura/escritura. & PL & PS \\ \hline
%    \end{tabular}
%\end{table}

% -------------------------------------------------------------
% SECCIÓN 4: El Core Técnico del Reporter
% -------------------------------------------------------------
\section{Técnicas de Trazabilidad y Asignación Temporal (Timestamping)}
\label{sec:timestamping}

Este es el segmento más importante, ya que sustenta el mecanismo propuesto por el Módulo Reporter.

\subsection{Mecanismos de Trazado de Eventos (Event Tracing)}
\label{ssec:event_tracing}
% Definición de qué constituye un "evento" de CPU (instrucción, interrupción, acceso).

\subsection{Generación de Marcas Temporales (Timestamps) en Hardware}
\label{ssec:generacion_timestamps}
% Cómo se genera un timestamp (contadores de clock).
% Análisis de la precisión y tolerancia requerida para STR.

\subsection{Problemas de Sincronización entre Dominios de Clock}
\label{ssec:sincronizacion_clock}
% Discusión sobre cómo asegurar la coherencia temporal al transferir datos entre el dominio del soft-core (PL) y el dominio del ARM (PS).
% Esto sustenta la necesidad de la "señal de referencia" de la hipótesis.

% -------------------------------------------------------------
% SECCIÓN 5: Antecedentes (Opcional)
% -------------------------------------------------------------
\section{Trabajos Relacionados y Antecedentes}
\label{sec:trabajos_relacionados}

\subsection{Herramientas de Debugging y Trazado Existentes}
\label{ssec:herramientas_existentes}
% Breve revisión crítica de soluciones comerciales o académicas similares, y cómo tu Módulo Reporter se diferencia/mejora estas soluciones.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
